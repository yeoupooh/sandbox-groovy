import groovy.beans.Bindable
import groovy.io.FileType
import groovy.swing.SwingBuilder
import groovy.xml.MarkupBuilder

import javax.swing.*
import javax.swing.filechooser.FileFilter

swing = new SwingBuilder()
swing.edt {
    lookAndFeel 'nimbus'
}

def loadEngines() {
    new Thread({
        def dir = new File("engines")
        dir.eachFileRecurse(FileType.FILES) { file ->
            if (file.name.endsWith('.groovy')) {
                new GroovyShell().parse(file).with { engine ->
                    println('found engine: ' + engine.toString() + ' from ' + file.toString())
                    cmbModel.engines.addElement(engine)
                }
            }
        }
    }).start()
}

def saveToXspf(model) {
    println('save to .xspf')

    def dialog = swing.fileChooser(
            dialogTitle: 'Save as .xspf file',
            fileSelectionMode: JFileChooser.FILES_ONLY,
            fileFilter: [
                    getDescription: { -> "xspf files" },
                    accept        : {
                        file -> file ==~ /.*?\.xspf/ || file.isDirectory()
                    }
            ] as FileFilter
    )
    if (dialog.showOpenDialog() != JFileChooser.APPROVE_OPTION) {
        println(dialog.selectedFile)
        return
    }

    def writer = new StringWriter()
    def xml = new MarkupBuilder(writer)
    xml.mkp.xmlDeclaration(version: "1.0", encoding: "utf-8")
    xml.playlist(xmlns: 'http://xspf.org/ns/0/', version: '1') {
        creator 'Automatically generated by subak groovy script'
        trackList {
            model.each { item ->
                println(item)
                track {
                    title item.track
                    creator item.artist
                    location String.valueOf(item.file)
                    duration item.length
                }
            }
        }
    }

    println(writer.toString())

    f = dialog.selectedFile
    f.text = writer.toString()
}

def loadTracks(resultTableModel, model) {
    new Thread({
        def result = cmbModel.selectedItem.search(keyword)
        println(result)
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            void run() {
                result.tracks.each { track ->
                    println(track)
                    model.add(['file'  : track.file, 'track': track.track,
                               'artist': track.artist, 'size': track.size,
                               'length': track.length, 'bitrate': track.bitrate])
                }
                resultTableModel.fireTableDataChanged()
                msg.text = 'Done.'
            }
        })
    }).start()
}

def createResultTable(keyword) {
    return swing.vbox {
        def model = []

        hbox {
            button('Close', actionPerformed: {
                println(tabs)
                println(tabs.selectedIndex)
                tabs.remove(tabs.selectedIndex)
            })
            button('Refresh', actionPerformed: {
                println('refresh')
                loadTracks(resultTableModel, model)
            })
            button('Save to .xspf', actionPerformed: {
                saveToXspf(model)
            })
            msg = label('Loading...')
        }
        scrollPane {
            table {
                def resultTableModel = tableModel(list: model) {
                    closureColumn(header: 'File', read: { row -> return row.file })
                    closureColumn(header: 'Track', read: { row -> return row.track })
                    closureColumn(header: 'Artist', read: { row -> return row.artist })
                    closureColumn(header: 'Size', read: { row -> return row.size })
                    closureColumn(header: 'Length', read: { row -> return row.length })
                    closureColumn(header: 'Bit Rate', read: { row -> return row.bitrate })
                }

                loadTracks(resultTableModel, model)
            }
        }
    }
}

class SelectableModel {
    @Bindable
    ComboBoxModel engines = new DefaultComboBoxModel()
    @Bindable
    def selectedItem
}

cmbModel = new SelectableModel()
cmb = swing.comboBox(
        model: cmbModel.engines,
        selectedItem: swing.bind(target: cmbModel, targetProperty: 'selectedItem')
)

tabs = swing.tabbedPane(id: 'tabs', tabLayoutPolicy: JTabbedPane.SCROLL_TAB_LAYOUT)

frame = swing.frame(title: 'Subak - delicious music', defaultCloseOperation: JFrame.EXIT_ON_CLOSE, location: [200, 100], size: [800, 600]) {
    menuBar {
        menu(text: 'Help') {
            menuItem() {
                action(name: 'About', closure: { showAbout() })
            }
        }
    }
    panel {
        borderLayout()
        hbox(constraints: NORTH) {
            widget(cmb)
            keyword = textField(keyPressed: { event ->
                if (event.keyCode == 10) {
                    search(keyword)
                }
            })
            button('Search', actionPerformed: {
                search(keyword)
            })
        }
        widget(tabs)
    }
}

def search(keyword) {
    println(keyword.text)
    tabs.add(keyword.text, createResultTable(keyword.text))
    println(tabs.tabCount)
    tabs.selectedIndex = tabs.tabCount - 1
}

frame.setVisible(true)

SwingUtilities.invokeLater(new Runnable() {
    @Override
    void run() {
        loadEngines()
    }
})

